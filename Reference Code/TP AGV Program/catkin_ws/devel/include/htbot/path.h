// Generated by gencpp from file htbot/path.msg
// DO NOT EDIT!


#ifndef HTBOT_MESSAGE_PATH_H
#define HTBOT_MESSAGE_PATH_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace htbot
{
template <class ContainerAllocator>
struct path_
{
  typedef path_<ContainerAllocator> Type;

  path_()
    : cmd(0)
    , px(0.0)
    , py(0.0)
    , pz(0.0)
    , prx(0.0)
    , pry(0.0)
    , prz(0.0)
    , prw(0.0)
    , gx(0.0)
    , gy(0.0)
    , gz(0.0)
    , grx(0.0)
    , gry(0.0)
    , grz(0.0)
    , grw(0.0)
    , tol(0.0)  {
    }
  path_(const ContainerAllocator& _alloc)
    : cmd(0)
    , px(0.0)
    , py(0.0)
    , pz(0.0)
    , prx(0.0)
    , pry(0.0)
    , prz(0.0)
    , prw(0.0)
    , gx(0.0)
    , gy(0.0)
    , gz(0.0)
    , grx(0.0)
    , gry(0.0)
    , grz(0.0)
    , grw(0.0)
    , tol(0.0)  {
  (void)_alloc;
    }



   typedef int8_t _cmd_type;
  _cmd_type cmd;

   typedef float _px_type;
  _px_type px;

   typedef float _py_type;
  _py_type py;

   typedef float _pz_type;
  _pz_type pz;

   typedef float _prx_type;
  _prx_type prx;

   typedef float _pry_type;
  _pry_type pry;

   typedef float _prz_type;
  _prz_type prz;

   typedef float _prw_type;
  _prw_type prw;

   typedef float _gx_type;
  _gx_type gx;

   typedef float _gy_type;
  _gy_type gy;

   typedef float _gz_type;
  _gz_type gz;

   typedef float _grx_type;
  _grx_type grx;

   typedef float _gry_type;
  _gry_type gry;

   typedef float _grz_type;
  _grz_type grz;

   typedef float _grw_type;
  _grw_type grw;

   typedef float _tol_type;
  _tol_type tol;





  typedef boost::shared_ptr< ::htbot::path_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::htbot::path_<ContainerAllocator> const> ConstPtr;

}; // struct path_

typedef ::htbot::path_<std::allocator<void> > path;

typedef boost::shared_ptr< ::htbot::path > pathPtr;
typedef boost::shared_ptr< ::htbot::path const> pathConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::htbot::path_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::htbot::path_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace htbot

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'geometry_msgs': ['/opt/ros/kinetic/share/geometry_msgs/cmake/../msg'], 'htbot': ['/home/rac/catkin_ws/src/htbot/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::htbot::path_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::htbot::path_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::htbot::path_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::htbot::path_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::htbot::path_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::htbot::path_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::htbot::path_<ContainerAllocator> >
{
  static const char* value()
  {
    return "0d2fce4d2355f03d0ce87b3bd4babb5e";
  }

  static const char* value(const ::htbot::path_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x0d2fce4d2355f03dULL;
  static const uint64_t static_value2 = 0x0ce87b3bd4babb5eULL;
};

template<class ContainerAllocator>
struct DataType< ::htbot::path_<ContainerAllocator> >
{
  static const char* value()
  {
    return "htbot/path";
  }

  static const char* value(const ::htbot::path_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::htbot::path_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int8 cmd\n\
float32 px\n\
float32 py\n\
float32 pz\n\
float32 prx\n\
float32 pry\n\
float32 prz\n\
float32 prw\n\
float32 gx\n\
float32 gy\n\
float32 gz\n\
float32 grx\n\
float32 gry\n\
float32 grz\n\
float32 grw\n\
float32 tol\n\
";
  }

  static const char* value(const ::htbot::path_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::htbot::path_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.cmd);
      stream.next(m.px);
      stream.next(m.py);
      stream.next(m.pz);
      stream.next(m.prx);
      stream.next(m.pry);
      stream.next(m.prz);
      stream.next(m.prw);
      stream.next(m.gx);
      stream.next(m.gy);
      stream.next(m.gz);
      stream.next(m.grx);
      stream.next(m.gry);
      stream.next(m.grz);
      stream.next(m.grw);
      stream.next(m.tol);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct path_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::htbot::path_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::htbot::path_<ContainerAllocator>& v)
  {
    s << indent << "cmd: ";
    Printer<int8_t>::stream(s, indent + "  ", v.cmd);
    s << indent << "px: ";
    Printer<float>::stream(s, indent + "  ", v.px);
    s << indent << "py: ";
    Printer<float>::stream(s, indent + "  ", v.py);
    s << indent << "pz: ";
    Printer<float>::stream(s, indent + "  ", v.pz);
    s << indent << "prx: ";
    Printer<float>::stream(s, indent + "  ", v.prx);
    s << indent << "pry: ";
    Printer<float>::stream(s, indent + "  ", v.pry);
    s << indent << "prz: ";
    Printer<float>::stream(s, indent + "  ", v.prz);
    s << indent << "prw: ";
    Printer<float>::stream(s, indent + "  ", v.prw);
    s << indent << "gx: ";
    Printer<float>::stream(s, indent + "  ", v.gx);
    s << indent << "gy: ";
    Printer<float>::stream(s, indent + "  ", v.gy);
    s << indent << "gz: ";
    Printer<float>::stream(s, indent + "  ", v.gz);
    s << indent << "grx: ";
    Printer<float>::stream(s, indent + "  ", v.grx);
    s << indent << "gry: ";
    Printer<float>::stream(s, indent + "  ", v.gry);
    s << indent << "grz: ";
    Printer<float>::stream(s, indent + "  ", v.grz);
    s << indent << "grw: ";
    Printer<float>::stream(s, indent + "  ", v.grw);
    s << indent << "tol: ";
    Printer<float>::stream(s, indent + "  ", v.tol);
  }
};

} // namespace message_operations
} // namespace ros

#endif // HTBOT_MESSAGE_PATH_H
