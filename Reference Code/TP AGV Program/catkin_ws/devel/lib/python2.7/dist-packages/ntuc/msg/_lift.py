# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from ntuc/lift.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class lift(genpy.Message):
  _md5sum = "e5880338d440c98c58ce479e42b36bed"
  _type = "ntuc/lift"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """##################################################
##### Message type: lift.msg
##### Use in Topics: /to_lift, /fr_lift
##################################################
int8 cmd			# command code			[0-102]
int8 cfloor			# start of trip [1-11] or current car level [1-11]
int8 dfloor			# end level of trip	[1-11]
int8 inuse			# request for in_use activation [0/1] or in_use status [0/1]
int8 dooropen		# door open status 	[0/1]
int8 doorclose		# door close status 	[0/1]
int8 goingup		# going up status 	[0/1]
int8 goingdown		# going down status 	[0/1]
int8 stationary		# stationary status 	[0/1]
int8 serviceavail	# service available status	[0/1]
int8 epower			# emergency power status 	[0/1]
int8 fireservice	# fire service status 		[0/1]
int8 beacon			# beacon light alarm 		[0/1], 1 to trigger, 0 to turn off

##################################################
##### cmd value usage:
##### 0:carCallStartLevel, 1:enteredLift, 2:carCallEndLevel, 3:exitedLift
##### 8:beacon, 9:inUse, 10:okay2Enter, 11:okay2Exit
##### 20:inUse, 21:doorOpen, 22:doorClose, 23:goingUp, 24:goingDown, 25:stationary 
##### 40:carLevel, 100:serviceAvailable, 101: emergencyPower, 102:fireServiceAlarm
##################################################
"""
  __slots__ = ['cmd','cfloor','dfloor','inuse','dooropen','doorclose','goingup','goingdown','stationary','serviceavail','epower','fireservice','beacon']
  _slot_types = ['int8','int8','int8','int8','int8','int8','int8','int8','int8','int8','int8','int8','int8']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       cmd,cfloor,dfloor,inuse,dooropen,doorclose,goingup,goingdown,stationary,serviceavail,epower,fireservice,beacon

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(lift, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.cmd is None:
        self.cmd = 0
      if self.cfloor is None:
        self.cfloor = 0
      if self.dfloor is None:
        self.dfloor = 0
      if self.inuse is None:
        self.inuse = 0
      if self.dooropen is None:
        self.dooropen = 0
      if self.doorclose is None:
        self.doorclose = 0
      if self.goingup is None:
        self.goingup = 0
      if self.goingdown is None:
        self.goingdown = 0
      if self.stationary is None:
        self.stationary = 0
      if self.serviceavail is None:
        self.serviceavail = 0
      if self.epower is None:
        self.epower = 0
      if self.fireservice is None:
        self.fireservice = 0
      if self.beacon is None:
        self.beacon = 0
    else:
      self.cmd = 0
      self.cfloor = 0
      self.dfloor = 0
      self.inuse = 0
      self.dooropen = 0
      self.doorclose = 0
      self.goingup = 0
      self.goingdown = 0
      self.stationary = 0
      self.serviceavail = 0
      self.epower = 0
      self.fireservice = 0
      self.beacon = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_13b().pack(_x.cmd, _x.cfloor, _x.dfloor, _x.inuse, _x.dooropen, _x.doorclose, _x.goingup, _x.goingdown, _x.stationary, _x.serviceavail, _x.epower, _x.fireservice, _x.beacon))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 13
      (_x.cmd, _x.cfloor, _x.dfloor, _x.inuse, _x.dooropen, _x.doorclose, _x.goingup, _x.goingdown, _x.stationary, _x.serviceavail, _x.epower, _x.fireservice, _x.beacon,) = _get_struct_13b().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_13b().pack(_x.cmd, _x.cfloor, _x.dfloor, _x.inuse, _x.dooropen, _x.doorclose, _x.goingup, _x.goingdown, _x.stationary, _x.serviceavail, _x.epower, _x.fireservice, _x.beacon))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 13
      (_x.cmd, _x.cfloor, _x.dfloor, _x.inuse, _x.dooropen, _x.doorclose, _x.goingup, _x.goingdown, _x.stationary, _x.serviceavail, _x.epower, _x.fireservice, _x.beacon,) = _get_struct_13b().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_13b = None
def _get_struct_13b():
    global _struct_13b
    if _struct_13b is None:
        _struct_13b = struct.Struct("<13b")
    return _struct_13b
