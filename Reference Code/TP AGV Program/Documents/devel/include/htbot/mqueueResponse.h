// Generated by gencpp from file htbot/mqueueResponse.msg
// DO NOT EDIT!


#ifndef HTBOT_MESSAGE_MQUEUERESPONSE_H
#define HTBOT_MESSAGE_MQUEUERESPONSE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace htbot
{
template <class ContainerAllocator>
struct mqueueResponse_
{
  typedef mqueueResponse_<ContainerAllocator> Type;

  mqueueResponse_()
    : status(0)
    , tx(0.0)
    , ty(0.0)
    , tz(0.0)
    , rx(0.0)
    , ry(0.0)
    , rz(0.0)
    , rw(0.0)
    , prd(0.0)
    , pra(0.0)
    , psd(0.0)
    , psa(0.0)
    , prd1(0.0)
    , pra1(0.0)
    , psd1(0.0)
    , psa1(0.0)
    , LP(0)
    , cLP(0)
    , nGP(0)
    , cGN(0)
    , nIQ(0)
    , marked(0)
    , gps()
    , lps()
    , lps1()
    , lps2()
    , lps3()
    , lps4()
    , lps5()
    , lps6()
    , lps7()
    , lps8()
    , marked1(0)
    , marked2(0)
    , marked3(0)
    , marked4(0)
    , marked5(0)
    , marked6(0)
    , marked7(0)
    , marked8(0)
    , align(0.0)
    , autostart(0.0)  {
    }
  mqueueResponse_(const ContainerAllocator& _alloc)
    : status(0)
    , tx(0.0)
    , ty(0.0)
    , tz(0.0)
    , rx(0.0)
    , ry(0.0)
    , rz(0.0)
    , rw(0.0)
    , prd(0.0)
    , pra(0.0)
    , psd(0.0)
    , psa(0.0)
    , prd1(0.0)
    , pra1(0.0)
    , psd1(0.0)
    , psa1(0.0)
    , LP(0)
    , cLP(0)
    , nGP(0)
    , cGN(0)
    , nIQ(0)
    , marked(0)
    , gps(_alloc)
    , lps(_alloc)
    , lps1(_alloc)
    , lps2(_alloc)
    , lps3(_alloc)
    , lps4(_alloc)
    , lps5(_alloc)
    , lps6(_alloc)
    , lps7(_alloc)
    , lps8(_alloc)
    , marked1(0)
    , marked2(0)
    , marked3(0)
    , marked4(0)
    , marked5(0)
    , marked6(0)
    , marked7(0)
    , marked8(0)
    , align(0.0)
    , autostart(0.0)  {
  (void)_alloc;
    }



   typedef int8_t _status_type;
  _status_type status;

   typedef float _tx_type;
  _tx_type tx;

   typedef float _ty_type;
  _ty_type ty;

   typedef float _tz_type;
  _tz_type tz;

   typedef float _rx_type;
  _rx_type rx;

   typedef float _ry_type;
  _ry_type ry;

   typedef float _rz_type;
  _rz_type rz;

   typedef float _rw_type;
  _rw_type rw;

   typedef float _prd_type;
  _prd_type prd;

   typedef float _pra_type;
  _pra_type pra;

   typedef float _psd_type;
  _psd_type psd;

   typedef float _psa_type;
  _psa_type psa;

   typedef float _prd1_type;
  _prd1_type prd1;

   typedef float _pra1_type;
  _pra1_type pra1;

   typedef float _psd1_type;
  _psd1_type psd1;

   typedef float _psa1_type;
  _psa1_type psa1;

   typedef int8_t _LP_type;
  _LP_type LP;

   typedef int8_t _cLP_type;
  _cLP_type cLP;

   typedef int8_t _nGP_type;
  _nGP_type nGP;

   typedef int8_t _cGN_type;
  _cGN_type cGN;

   typedef int8_t _nIQ_type;
  _nIQ_type nIQ;

   typedef int8_t _marked_type;
  _marked_type marked;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _gps_type;
  _gps_type gps;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _lps_type;
  _lps_type lps;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _lps1_type;
  _lps1_type lps1;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _lps2_type;
  _lps2_type lps2;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _lps3_type;
  _lps3_type lps3;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _lps4_type;
  _lps4_type lps4;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _lps5_type;
  _lps5_type lps5;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _lps6_type;
  _lps6_type lps6;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _lps7_type;
  _lps7_type lps7;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _lps8_type;
  _lps8_type lps8;

   typedef int8_t _marked1_type;
  _marked1_type marked1;

   typedef int8_t _marked2_type;
  _marked2_type marked2;

   typedef int8_t _marked3_type;
  _marked3_type marked3;

   typedef int8_t _marked4_type;
  _marked4_type marked4;

   typedef int8_t _marked5_type;
  _marked5_type marked5;

   typedef int8_t _marked6_type;
  _marked6_type marked6;

   typedef int8_t _marked7_type;
  _marked7_type marked7;

   typedef int8_t _marked8_type;
  _marked8_type marked8;

   typedef float _align_type;
  _align_type align;

   typedef float _autostart_type;
  _autostart_type autostart;





  typedef boost::shared_ptr< ::htbot::mqueueResponse_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::htbot::mqueueResponse_<ContainerAllocator> const> ConstPtr;

}; // struct mqueueResponse_

typedef ::htbot::mqueueResponse_<std::allocator<void> > mqueueResponse;

typedef boost::shared_ptr< ::htbot::mqueueResponse > mqueueResponsePtr;
typedef boost::shared_ptr< ::htbot::mqueueResponse const> mqueueResponseConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::htbot::mqueueResponse_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::htbot::mqueueResponse_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace htbot

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': False}
// {'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'geometry_msgs': ['/opt/ros/kinetic/share/geometry_msgs/cmake/../msg'], 'htbot': ['/home/rac/catkin_ws/src/htbot/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::htbot::mqueueResponse_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::htbot::mqueueResponse_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::htbot::mqueueResponse_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::htbot::mqueueResponse_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::htbot::mqueueResponse_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::htbot::mqueueResponse_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::htbot::mqueueResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "a6a4649df65d8320dbceeee83af7bd77";
  }

  static const char* value(const ::htbot::mqueueResponse_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xa6a4649df65d8320ULL;
  static const uint64_t static_value2 = 0xdbceeee83af7bd77ULL;
};

template<class ContainerAllocator>
struct DataType< ::htbot::mqueueResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "htbot/mqueueResponse";
  }

  static const char* value(const ::htbot::mqueueResponse_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::htbot::mqueueResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int8 status\n\
float32 tx\n\
float32 ty\n\
float32 tz\n\
float32 rx\n\
float32 ry\n\
float32 rz\n\
float32 rw\n\
float32 prd\n\
float32 pra\n\
float32 psd\n\
float32 psa\n\
float32 prd1\n\
float32 pra1\n\
float32 psd1\n\
float32 psa1\n\
int8 LP\n\
int8 cLP\n\
int8 nGP\n\
int8 cGN\n\
int8 nIQ\n\
int8 marked\n\
string gps\n\
string lps\n\
string lps1\n\
string lps2\n\
string lps3\n\
string lps4\n\
string lps5\n\
string lps6\n\
string lps7\n\
string lps8\n\
int8 marked1\n\
int8 marked2\n\
int8 marked3\n\
int8 marked4\n\
int8 marked5\n\
int8 marked6\n\
int8 marked7\n\
int8 marked8\n\
float32 align\n\
float32 autostart\n\
\n\
";
  }

  static const char* value(const ::htbot::mqueueResponse_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::htbot::mqueueResponse_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.status);
      stream.next(m.tx);
      stream.next(m.ty);
      stream.next(m.tz);
      stream.next(m.rx);
      stream.next(m.ry);
      stream.next(m.rz);
      stream.next(m.rw);
      stream.next(m.prd);
      stream.next(m.pra);
      stream.next(m.psd);
      stream.next(m.psa);
      stream.next(m.prd1);
      stream.next(m.pra1);
      stream.next(m.psd1);
      stream.next(m.psa1);
      stream.next(m.LP);
      stream.next(m.cLP);
      stream.next(m.nGP);
      stream.next(m.cGN);
      stream.next(m.nIQ);
      stream.next(m.marked);
      stream.next(m.gps);
      stream.next(m.lps);
      stream.next(m.lps1);
      stream.next(m.lps2);
      stream.next(m.lps3);
      stream.next(m.lps4);
      stream.next(m.lps5);
      stream.next(m.lps6);
      stream.next(m.lps7);
      stream.next(m.lps8);
      stream.next(m.marked1);
      stream.next(m.marked2);
      stream.next(m.marked3);
      stream.next(m.marked4);
      stream.next(m.marked5);
      stream.next(m.marked6);
      stream.next(m.marked7);
      stream.next(m.marked8);
      stream.next(m.align);
      stream.next(m.autostart);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct mqueueResponse_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::htbot::mqueueResponse_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::htbot::mqueueResponse_<ContainerAllocator>& v)
  {
    s << indent << "status: ";
    Printer<int8_t>::stream(s, indent + "  ", v.status);
    s << indent << "tx: ";
    Printer<float>::stream(s, indent + "  ", v.tx);
    s << indent << "ty: ";
    Printer<float>::stream(s, indent + "  ", v.ty);
    s << indent << "tz: ";
    Printer<float>::stream(s, indent + "  ", v.tz);
    s << indent << "rx: ";
    Printer<float>::stream(s, indent + "  ", v.rx);
    s << indent << "ry: ";
    Printer<float>::stream(s, indent + "  ", v.ry);
    s << indent << "rz: ";
    Printer<float>::stream(s, indent + "  ", v.rz);
    s << indent << "rw: ";
    Printer<float>::stream(s, indent + "  ", v.rw);
    s << indent << "prd: ";
    Printer<float>::stream(s, indent + "  ", v.prd);
    s << indent << "pra: ";
    Printer<float>::stream(s, indent + "  ", v.pra);
    s << indent << "psd: ";
    Printer<float>::stream(s, indent + "  ", v.psd);
    s << indent << "psa: ";
    Printer<float>::stream(s, indent + "  ", v.psa);
    s << indent << "prd1: ";
    Printer<float>::stream(s, indent + "  ", v.prd1);
    s << indent << "pra1: ";
    Printer<float>::stream(s, indent + "  ", v.pra1);
    s << indent << "psd1: ";
    Printer<float>::stream(s, indent + "  ", v.psd1);
    s << indent << "psa1: ";
    Printer<float>::stream(s, indent + "  ", v.psa1);
    s << indent << "LP: ";
    Printer<int8_t>::stream(s, indent + "  ", v.LP);
    s << indent << "cLP: ";
    Printer<int8_t>::stream(s, indent + "  ", v.cLP);
    s << indent << "nGP: ";
    Printer<int8_t>::stream(s, indent + "  ", v.nGP);
    s << indent << "cGN: ";
    Printer<int8_t>::stream(s, indent + "  ", v.cGN);
    s << indent << "nIQ: ";
    Printer<int8_t>::stream(s, indent + "  ", v.nIQ);
    s << indent << "marked: ";
    Printer<int8_t>::stream(s, indent + "  ", v.marked);
    s << indent << "gps: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.gps);
    s << indent << "lps: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.lps);
    s << indent << "lps1: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.lps1);
    s << indent << "lps2: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.lps2);
    s << indent << "lps3: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.lps3);
    s << indent << "lps4: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.lps4);
    s << indent << "lps5: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.lps5);
    s << indent << "lps6: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.lps6);
    s << indent << "lps7: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.lps7);
    s << indent << "lps8: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.lps8);
    s << indent << "marked1: ";
    Printer<int8_t>::stream(s, indent + "  ", v.marked1);
    s << indent << "marked2: ";
    Printer<int8_t>::stream(s, indent + "  ", v.marked2);
    s << indent << "marked3: ";
    Printer<int8_t>::stream(s, indent + "  ", v.marked3);
    s << indent << "marked4: ";
    Printer<int8_t>::stream(s, indent + "  ", v.marked4);
    s << indent << "marked5: ";
    Printer<int8_t>::stream(s, indent + "  ", v.marked5);
    s << indent << "marked6: ";
    Printer<int8_t>::stream(s, indent + "  ", v.marked6);
    s << indent << "marked7: ";
    Printer<int8_t>::stream(s, indent + "  ", v.marked7);
    s << indent << "marked8: ";
    Printer<int8_t>::stream(s, indent + "  ", v.marked8);
    s << indent << "align: ";
    Printer<float>::stream(s, indent + "  ", v.align);
    s << indent << "autostart: ";
    Printer<float>::stream(s, indent + "  ", v.autostart);
  }
};

} // namespace message_operations
} // namespace ros

#endif // HTBOT_MESSAGE_MQUEUERESPONSE_H
