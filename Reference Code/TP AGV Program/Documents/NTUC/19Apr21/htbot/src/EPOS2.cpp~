/*
 * EPOS Class 
 */
#include <exception>
#include "htbot/EPOS2.h"

//#define BAUDRATE B115200 
#define BAUDRATE B57600 
//#define DEBUG 
#define TRY 6

////////////////////////////////////////////////////////////////////////////////
// Constructor
EPOS::EPOS()
{
	NodeID=0x01;
}

////////////////////////////////////////////////////////////////////////////////
// Destructor
EPOS::~EPOS()
{
	//closePort();
}


////////////////////////////////////////////////////////////////////////////////
// Open the EPOS port
int
EPOS::openPort(const char* port_name,unsigned short baud)
{
	// Open the port
	fd = open(port_name, O_RDWR | O_NOCTTY );
	if (fd <0)
	{
		printf("Cannot open port %s \n", port_name); 
	}
	else
	{
		port = port_name; //save a copy of the port name
		printf("Port %s opened with fd=%i\n", port,fd);

		tcgetattr(fd,&oldtio); /* save current serial port settings */
		bzero(&newtio, sizeof(newtio)); /* clear struct for new port settings */

		/* 
			BAUDRATE: Set bps rate. You could also use cfsetispeed and cfsetospeed.
			CS8		: 8n1 (8bit,no parity,1 stopbit)
			CLOCAL	: local connection, no modem contol
			CREAD	: enable receiving characters
		*/
		switch (baud) {
			case 2: // B19200
				newtio.c_cflag = B19200 | CS8 | CLOCAL | CREAD;
				break;
			case 3: // B38400
				newtio.c_cflag = B38400 | CS8 | CLOCAL | CREAD;
				break;
			case 4: // B57600
				newtio.c_cflag = B57600 | CS8 | CLOCAL | CREAD;
				break;
			case 5: // B115200
				newtio.c_cflag = B115200 | CS8 | CLOCAL | CREAD;
				break;
		}
		//newtio.c_cflag = BAUDRATE | CS8 | CLOCAL | CREAD;
		newtio.c_oflag = 0;

		newtio.c_cc[VMIN] = 0;	/* min number of char read, 0 means enable timeout */
		newtio.c_cc[VTIME] = 1;	/* timeout in deciseconds */

		/* 
			now clean the Tx and Rx line and activate the settings for the port
		*/
		tcflush(fd, TCIOFLUSH);
		tcsetattr(fd,TCSANOW,&newtio);
	}
	return fd;
} //EPOS::openPort


////////////////////////////////////////////////////////////////////////////////
// Close the EPOS port
bool
EPOS::closePort()
{
	if (fd != -1)
	{
		tcsetattr(fd,TCSANOW,&oldtio); //restore port settings
		if (close(fd) != 0)
		{
			printf("Unable to close serial port %s, fd=%i. Error: %s\n",port,fd,strerror(errno));
			fd = -1;
			return false;
		}
		else 
		{
			printf("Port %s, fd=%i is closed successfully\n",port,fd);
			fd = -1;
			return true;
		}
	}
	else printf("Serial port already closed\n");
	return true;
}


////////////////////////////////////////////////////////////////////////////////
// Calculate CRC of data
unsigned short 
EPOS::CRCCalc(unsigned short buf[],unsigned short len)
{
	unsigned short shifter, c;
	unsigned short carry;
 	unsigned short crc = 0;
 	int i = 0;
 	while (len > 0)
 	{
		shifter = 0x8000;
		c = buf[i++];
		do
		{
		 	carry = (unsigned short) (crc & 0x8000);
			crc <<= 1;
			if ((c & shifter)>0) crc++;
			if (carry > 0) crc ^= 0x1021;
			shifter >>= 1;
		} while (shifter > 0);
		len--;
 	}
	return crc;
}

////////////////////////////////////////////////////////////////////////////////
// Check ACK of data sent
bool 
EPOS::checkAck()
{
	int cnt = 0;
	int res;
	unsigned char rd;
	bool ret;

	while (true)
	{
		//usleep(5000);
		res = read(fd,&rd,1); 
		if (rd == 0x4f) {// 'O' = 0x4f
			//printf("received okay");
			ret = true;
		 	break;
		} 
		else
		{
			if (rd == 0x46) {// 'F' = 0x46
				ret = false;
				break;
			} else {
				cnt++;
				if (cnt < 5) {
					continue;
				} else {
					ret = false;
					break;
				}
			}
		}
	}
	return ret;
}

////////////////////////////////////////////////////////////////////////////////
// Check for reply of opcode 
bool 
EPOS::checkReplyOpCode()
{
	int cnt = 0;
	unsigned char rd;
	int res;

	while (true)
	{
		//usleep(5000);
		res = read(fd,&rd,1); 
		if (res!=0 && rd == 0x00)
			break;
		else
		{
		#ifdef DEBUG
			printf("Try %i, res=%i: Instead of opCode 0x00 I got 0x%x\n",cnt+1,res,rd);
		#endif
			//usleep(20000);
			cnt++;
			if (cnt < 5) continue;
			else return false;
		}
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////
// Read Data 
bool 
EPOS::readData(unsigned char buf[],int len)
{
	int cnt = 0;
	int res;
	unsigned char rd;

	while (len > 0)
	{
		res = read(fd,&rd,1);
		buf[cnt] = rd;
		cnt++;
		len--;
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////
// Read Object 
bool 
EPOS::readObject(unsigned char inxhigh, unsigned char inxlow, unsigned char subindex,unsigned char bparam[],int& lx)
{
	unsigned char sbuff[10];
	int res;
	unsigned short x, crc;
	int len;

	// send opcode 
	sbuff[0] = 0x10; // opcode for read 4 data bytes or less
	res=write(fd,sbuff,1);

	// wait for acknowledge from EPOS
	if (!checkAck())
	{
	#ifdef DEBUG
		printf("readObject: Did not get acknowledge after opcode sent\n");
	#endif
		return false;
	}
	
	// send len-1
	sbuff[0] = 0x01; // len -1 
	res=write(fd,sbuff,1);

	// send data
	sbuff[0] = inxlow; // index low byte
	sbuff[1] = inxhigh; // index high byte
	sbuff[2] = subindex; // subindex
	sbuff[3] = NodeID; // node id
	res=write(fd,sbuff,4);

	// calc crc and send
	data[0] = 0x1001;
	x = (unsigned short)(inxhigh * 256);
	data[1] = (unsigned short)(x + inxlow);
	x = (unsigned short)(NodeID * 256);
	data[2] = (unsigned short)(x + subindex);
	data[3] = 0x0000; // zero data
	x = CRCCalc(data,4);
	crc = x;
	sbuff[0] = (unsigned char)(x & 0x00ff);
	sbuff[1] = (unsigned char)((x & 0xff00) >> 8);
	res=write(fd,sbuff,2);

	// wait for end acknowledge from EPOS
	if (!checkAck())
	{
	#ifdef DEBUG
		printf("readObject: Did not get acknowledge after data sent\n");
	#endif
		return false;
	}
	
	// receive response from epos
	if (!checkReplyOpCode())
	{
	#ifdef DEBUG
		printf("readObject: Did not get opcode reply\n");
	#endif
		return false;
	}

	// send ack
	sbuff[0] = 0x4F; // ack
	res=write(fd,sbuff,1);

	// receive len - 1
	if (!readData(sbuff,1))
	{
	#ifdef DEBUG
		printf("readObject: Did not get len of data after ack\n");
	#endif
		return false;
	}
	
	len = sbuff[0] + 1;
	lx = len;
	len = len * 2;
	
	// read data of length len
	if (!readData(bparam, len))
	{
	#ifdef DEBUG
		printf("readObject: Did not get data\n");
	#endif
		return false;
	}
	
	// read crc
	if (!readData(sbuff, 2))
	{
	#ifdef DEBUG
		printf("readObject: Did not get crc\n");
	#endif
		return false;
	}
	
	// check crc and send ack
	// calc crc
	data[0] = 0x0003;
	x = (unsigned short)(bparam[1] * 256);
	data[1] = (unsigned short)(x + bparam[0]);
	x = (unsigned short)(bparam[3] * 256);
	data[2] = (unsigned short)(x + bparam[2]);
	x = (unsigned short)(bparam[5] * 256);
	data[3] = (unsigned short)(x + bparam[4]);
	x = (unsigned short)(bparam[7] * 256);
	data[4] = (unsigned short)(x + bparam[6]);
	data[5] = 0x0000; // zero data
	x = CRCCalc(data, 6);
	crc = x;

	x = (unsigned short)(sbuff[1] * 256);
	x = (unsigned short)(x + sbuff[0]);
	if (x == crc)
	{
		sbuff[0] = 0x4F; // send okay ack
		res=write(fd,sbuff,1);
		return true;
	}
	else
	{
		sbuff[0] = 0x46; // send failed 'F'
		res=write(fd,sbuff,1);
	#ifdef DEBUG
		printf("readObject: Wrong crc\n");
	#endif
		return false;
	}
} // bool EPOS::readObject

////////////////////////////////////////////////////////////////////////////////
// Write Object 
bool 
EPOS::writeObject(unsigned char inxhigh, unsigned char inxlow, unsigned char subindex,unsigned char bparam[])
{
	unsigned char sbuff[10];
	unsigned short x, crc, err, err1;
	int len,res;

	// send opcode 
	sbuff[0] = 0x11; // opcode for write 4 data bytes or less
	res=write(fd,sbuff,1);

	// wait for acknowledge from EPOS
	if (!checkAck())
	{
	#ifdef DEBUG
		printf("writeObject: Did not get acknowledge after opcode sent\n");
	#endif
		return false;
	}
	
	// send len-1
	sbuff[0] = 0x03; // len-1 
	res=write(fd,sbuff,1);

	// send data
	sbuff[0] = inxlow; // index low byte
	sbuff[1] = inxhigh; // index high byte
	sbuff[2] = subindex; // subindex
	sbuff[3] = NodeID; // node id
	sbuff[4] = bparam[0]; // 4 data bytes
	sbuff[5] = bparam[1];
	sbuff[6] = bparam[2];
	sbuff[7] = bparam[3];
	res=write(fd,sbuff,8);

	// calc crc and send
	data[0] = 0x1103;
	x = (unsigned short)(inxhigh * 256);
	data[1] = (unsigned short)(x + inxlow);
	x = (unsigned short)(NodeID * 256);
	data[2] = (unsigned short)(x + subindex);
	x = (unsigned short)(bparam[1] * 256);
	data[3] = (unsigned short)(x + bparam[0]);
	x = (unsigned short)(bparam[3] * 256);
	data[4] = (unsigned short)(bparam[2] + x);
	data[5] = 0x0000; // zero data
	x = CRCCalc(data, 6);
	crc = x;
	sbuff[0] = (unsigned char)(x & 0x00ff);
	sbuff[1] = (unsigned char)((x & 0xff00) >> 8);
	res=write(fd,sbuff,2);

	// wait for end acknowledge from EPOS
	if (!checkAck())
	{
	#ifdef DEBUG
		printf("writeObject: Did not get acknowledge after data sent\n");
	#endif
		return false;
	}

	// receive response from epos
	if (!checkReplyOpCode())
	{
	#ifdef DEBUG
		printf("writeObject: Did not get opcode reply\n");
	#endif
		return false;
	}

	// send ack
	sbuff[0] = 0x4F; // ack
	res=write(fd,sbuff,1);

	// receive len - 1
	if (!readData(sbuff, 1))
	{
	#ifdef DEBUG
		printf("writeObject: Did not get len of data after ack\n");
	#endif
		return false;
	}
	len = (sbuff[0] + 1) * 2;

	// read data of length len
	if (!readData(sbuff, len))
	{
	#ifdef DEBUG
		printf("writeObject: Did not get data\n");
	#endif
		return false;
	}

	// error code
	err = (unsigned short)(sbuff[1] * 256);
	err = (unsigned short)(err + sbuff[0]);
	err1 = (unsigned short)(sbuff[3] * 256);
	err1 = (unsigned short)(err + sbuff[2]);
	
	// read crc
	if (!readData(sbuff, 2))
	{
	#ifdef DEBUG
		printf("writeObject: Did not get crc\n");
	#endif
		return false;
	}

	// check crc and send ack
	// calc crc
	data[0] = 0x0001;
	data[1] = err;
	data[2] = err1;
	data[3] = 0x0000; // zero data
	x = CRCCalc(data, 4);
	crc = x;
	x = (unsigned short)(sbuff[1] * 256);
	x = (unsigned short)(x + sbuff[0]);

	if (x == crc)
	{
		sbuff[0] = 0x4F; // send okay ack
		res=write(fd,sbuff,1);
		return true;
	}
	else
	{
		sbuff[0] = 0x46; // send failed
		res=write(fd,sbuff,1);
	#ifdef DEBUG
		printf("writeObject: Wrong crc, err = %0x\n",err);
	#endif
		return false;
	}
} // bool EPOS::writeObject


////////////////////////////////////////////////////////////////////////////////
// getError helper function in getting error code when reading from EPOS
unsigned int 
EPOS::getError(unsigned char bparam[])
{

 	unsigned int err, temp;

	err = (unsigned int)(bparam[0]);
	temp = (unsigned int)(bparam[1]);
	err = err + (temp << 8);
	temp = (unsigned int)(bparam[2]);
	err = err + (temp << 16);
	temp = (unsigned int)(bparam[3]);
	err = err + (temp << 24);
	return err;
}

////////////////////////////////////////////////////////////////////////////////
 
void 
EPOS::GetCurrentRegulatorPGain()
{

 	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 

	for (int k=0;k<TRY;k++) {
	if (readObject(0x60, 0xf6, 0x01,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			CurrentRegulatorPGain = (short)(bparam[4] + bparam[5] * 256);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetCurrentRegulatorPGain(short pgain)
{

 	bool rs;
	unsigned char bparam[10];

	CurrentRegulatorPGain = pgain;
	bparam[0] = (unsigned char)(0x00ff & pgain);
	bparam[1] = (unsigned char)((0xff00 & pgain) >> 8);
	bparam[2] = 0x00;
	bparam[3] = 0x00;

	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0xf6, 0x01, bparam);
	//printf("\SetCurrentRegulatorPGain : %d\n",CurrentRegulatorPGain);	
	if (rs) {		
		break;
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
 
void 
EPOS::GetCurrentRegulatorIGain()
{

 	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 

	for (int k=0;k<TRY;k++) {
	if (readObject(0x60, 0xf6, 0x02,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			CurrentRegulatorIGain = (short)(bparam[4] + bparam[5] * 256);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetCurrentRegulatorIGain(short pgain)
{

 	bool rs;
	unsigned char bparam[10];

	CurrentRegulatorIGain = pgain;
	bparam[0] = (unsigned char)(0x00ff & pgain);
	bparam[1] = (unsigned char)((0xff00 & pgain) >> 8);
	bparam[2] = 0x00;
	bparam[3] = 0x00;

	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0xf6, 0x02, bparam);
	//printf("\SetCurrentRegulatorIGain : %d\n",CurrentRegulatorIGain);	
	if (rs) {
		break;
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
 
void 
EPOS::GetEncoderCount()
{

 	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 

	for (int k=0;k<TRY;k++) {
	if (readObject(0x22, 0x10, 0x01,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			IncrementalEncoderCount = (unsigned short)(bparam[4] + bparam[5] * 256);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetEncoderCount(unsigned short count) // can only be changed in 'Disable' state
{

 	bool rs;
	unsigned char bparam[10];

	IncrementalEncoderCount = count;
	bparam[0] = (unsigned char)(0x00ff & count);
	bparam[1] = (unsigned char)((0xff00 & count) >> 8);
	bparam[2] = 0x00;
	bparam[3] = 0x00;

	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x22, 0x10, 0x01, bparam);	
	if (rs) {
		break;
	}
	}
}


////////////////////////////////////////////////////////////////////////////////
// 
void 
EPOS::GetEncoderType()
{

 	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 

	for (int k=0;k<TRY;k++) {
	if (readObject(0x22, 0x10, 0x02,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			PositionSensorType = (unsigned short)(bparam[4] + bparam[5] * 256);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetEncoderType(unsigned short type) // can only be changed in 'Disable' state
{

 	bool rs;
	unsigned char bparam[10];

	PositionSensorType = type;
	bparam[0] = (unsigned char)(0x00ff & type);
	bparam[1] = (unsigned char)((0xff00 & type) >> 8);
	bparam[2] = 0x00;
	bparam[3] = 0x00;
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x22, 0x10, 0x02, bparam);
	if (rs) {
		break;
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
 
void 
EPOS::GetMotorType()
{

 	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x64, 0x02, 0x00,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			MotorType = (unsigned short)(bparam[4] + bparam[5] * 256);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetMotorType(unsigned short type) // can only be changed in "Disable" state
{

 	bool rs;
	unsigned char bparam[10];

	MotorType = type;
	bparam[0] = (unsigned char)(0x00ff & type);
	bparam[1] = (unsigned char)((0xff00 & type) >> 8);
	bparam[2] = 0x00;
	bparam[3] = 0x00;
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x64, 0x02, 0x00, bparam);
	if (rs) {
		break;
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
 
void 
EPOS::GetMotorMaxContCurrent()
{

 	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x64, 0x10, 0x01,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			MotorMaxContinuousCurrent = (unsigned short)(bparam[4] + bparam[5] * 256);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetMotorMaxContCurrent(unsigned short amp)
{

	bool rs;
	unsigned char bparam[10];

	MotorMaxContinuousCurrent = amp;
	bparam[0] = (unsigned char)(0x00ff & amp);
	bparam[1] = (unsigned char)((0xff00 & amp) >> 8);
	bparam[2] = 0x00;
	bparam[3] = 0x00;
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x64, 0x10, 0x01, bparam);	
	if (rs) {
		break;
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::GetMotorMaxPeakCurrent()
{
	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x64, 0x10, 0x02,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			MotorMaxPeakCurrent = (unsigned short)(bparam[4] + bparam[5] * 256);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetMotorMaxPeakCurrent(unsigned short amp)
{
	bool rs;
	unsigned char bparam[10];

	MotorMaxPeakCurrent = amp;
	bparam[0] = (unsigned char)(0x00ff & amp);
	bparam[1] = (unsigned char)((0xff00 & amp) >> 8);
	bparam[2] = 0x00;
	bparam[3] = 0x00;
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x64, 0x10, 0x02, bparam);	
	if (rs) {
		break;
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::GetMaxFollowError()
{

 	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x60, 0x65, 0x00,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			MaxFollowError = (unsigned int)(bparam[4] + bparam[5] * 256 + bparam[6] * 65536 + bparam[7] * 16777216);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetMaxFollowError(unsigned int error)
{
	bool rs;
	unsigned char bparam[10];

	MaxFollowError = error;
	bparam[0] = (unsigned char)(0x000000ff & error);
	bparam[1] = (unsigned char)((0x0000ff00 & error) >> 8);
	bparam[2] = (unsigned char)((0x00ff0000 & error) >> 16);
	bparam[3] = (unsigned char)((0xff000000 & error) >> 24);
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0x65, 0x00, bparam);
	if (rs) {
		break;
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::GetPositionPGain()
{
 	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x60, 0xfb, 0x01,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			PositionPGain = (unsigned short)(bparam[4] + bparam[5] * 256);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetPositionPGain(short gain)
{
 	bool rs;
	unsigned char bparam[10];

	PositionPGain = gain;
	bparam[0] = (unsigned char)(0x00ff & gain);
	bparam[1] = (unsigned char)((0xff00 & gain) >> 8);
	bparam[2] = 0x00;
	bparam[3] = 0x00;
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0xfb, 0x01, bparam);
	if (rs) {
		break;
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::GetPositionIGain()
{
 	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x60, 0xfb, 0x02,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			PositionIGain = (unsigned short)(bparam[4] + bparam[5] * 256);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetPositionIGain(short gain)
{
 	bool rs;
	unsigned char bparam[10];

	PositionIGain = gain;
	bparam[0] = (unsigned char)(0x00ff & gain);
	bparam[1] = (unsigned char)((0xff00 & gain) >> 8);
	bparam[2] = 0x00;
	bparam[3] = 0x00;
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0xfb, 0x02, bparam);	
	if (rs) {
		break;
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::GetPositionDGain()
{
	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x60, 0xfb, 0x03,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			PositionDGain = (unsigned short)(bparam[4] + bparam[5] * 256);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetPositionDGain(short gain)
{
	bool rs;
	unsigned char bparam[10];

	PositionDGain = gain;
	bparam[0] = (unsigned char)(0x00ff & gain);
	bparam[1] = (unsigned char)((0xff00 & gain) >> 8);
	bparam[2] = 0x00;
	bparam[3] = 0x00;
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0xfb, 0x03, bparam);
	if (rs) {
		break;
	}
	}
}


////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::GetVelocityPGain()
{
 	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x60, 0xf9, 0x01,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			VelocityPGain = (unsigned short)(bparam[4] + bparam[5] * 256);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetVelocityPGain(short gain)
{
 	bool rs;
	unsigned char bparam[10];

	VelocityPGain = gain;
	bparam[0] = (unsigned char)(0x00ff & gain);
	bparam[1] = (unsigned char)((0xff00 & gain) >> 8);
	bparam[2] = 0x00;
	bparam[3] = 0x00;
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0xf9, 0x01, bparam);	
	if (rs) {
		break;
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
// 
void 
EPOS::GetVelocityIGain()
{
 	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x60, 0xf9, 0x02,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			VelocityIGain = (unsigned short)(bparam[4] + bparam[5] * 256);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetVelocityIGain(short gain)
{
 	bool rs;
	unsigned char bparam[10];

	VelocityIGain = gain;
	bparam[0] = (unsigned char)(0x00ff & gain);
	bparam[1] = (unsigned char)((0xff00 & gain) >> 8);
	bparam[2] = 0x00;
	bparam[3] = 0x00;
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0xf9, 0x02, bparam);	
	if (rs) {
		break;
	}
	}
}


////////////////////////////////////////////////////////////////////////////////
 
bool 
EPOS::GetStatusWord()
{
 	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x60, 0x41, 0x00,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			StatusWord = (unsigned short)(bparam[4] + bparam[5] * 256);
			//printf("\GetStatusWord : %x\n",StatusWord & 0x417f);
			return true;
		}
	}	
	}
	printf("Failed to GetStatusWord\n");
	return false;
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetStatusWord(unsigned short swd)
{
	bool rs;
	unsigned char bparam[10];

	StatusWord = swd;
	bparam[0] = (unsigned char)(0x00ff & swd);
	bparam[1] = (unsigned char)((0xff00 & swd) >> 8);
	bparam[2] = 0x00;
	bparam[3] = 0x00;
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0x41, 0x00, bparam);
	if (rs) {
		break;
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
 
bool 
EPOS::GetControlWord()
{
 	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 	
	
	for (int k=0;k<TRY;k++) {
		if (readObject(0x60, 0x40, 0x00,bparam,lx))
		{
			// check for error code		
			err = getError(bparam);
			if (err == 0)
			{
				ControlWord = (unsigned short)(bparam[4] + bparam[5] * 256);
				return true;
			}
		}
	}
	printf("Failed to GetControlWord\n");
	return false;
}

////////////////////////////////////////////////////////////////////////////////
//
bool 
EPOS::SetControlWord(unsigned short cwd)
{
	bool rs;
	unsigned char bparam[10];
	bool ret = false;
	ControlWord = cwd;
	bparam[0] = (unsigned char)(0x00ff & cwd);
	bparam[1] = (unsigned char)((0xff00 & cwd) >> 8);
	bparam[2] = 0x00;
	bparam[3] = 0x00;

	for (int k=0;k<TRY;k++) {
		rs = writeObject(0x60, 0x40, 0x00, bparam);
		if (rs)
		{
			return false;
		} 
	}
	return false;
}


////////////////////////////////////////////////////////////////////////////////
 
void 
EPOS::GetCurrentModeSetting()
{
	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x20, 0x30, 0x00,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			CurrentModeSetting = (short)(bparam[4] + bparam[5] * 256);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetCurrentModeSetting(short current)
{
	bool rs;
	unsigned char bparam[10];

	CurrentModeSetting = current;
	bparam[0] = (unsigned char)(0x00ff & current);
	bparam[1] = (unsigned char)((0xff00 & current) >> 8);
	bparam[2] = 0x00;
	bparam[3] = 0x00;
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x20, 0x30, 0x00, bparam);
	if (rs) {
		break;
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
 
void 
EPOS::GetThermalTimeConstantWinding()
{
	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x64, 0x10, 0x05,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			ThermalTimeConstantWinding = (unsigned short)(bparam[4] + bparam[5] * 256);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetThermalTimeConstantWinding(unsigned short thermaltime)
{
	bool rs;
	unsigned char bparam[10];

	ThermalTimeConstantWinding = thermaltime;
	bparam[0] = (unsigned char)(0x00ff & thermaltime);
	bparam[1] = (unsigned char)((0xff00 & thermaltime) >> 8);
	bparam[2] = 0x00;
	bparam[3] = 0x00;
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x64, 0x10, 0x05, bparam);
	if (rs) {
		break;
	}
	}
}


////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::GetRS232BaudRate()
{
	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x20, 0x02, 0x00,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			RS232BaudRate = (unsigned short)(bparam[4] + bparam[5] * 256);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
bool 
EPOS::SetRS232BaudRate(unsigned short rate)
{
	bool rs;
	unsigned char bparam[10];

	RS232BaudRate = rate;
	bparam[0] = (unsigned char)(0x00ff & rate);
	bparam[1] = (unsigned char)((0xff00 & rate) >> 8);
	bparam[2] = 0x00;
	bparam[3] = 0x00;
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x20, 0x02, 0x00, bparam);
	if (rs) {
		return true;
	}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::GetCurrent()
{
	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x60, 0x78, 0x00,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			ActualCurrent = (short)(bparam[4] + bparam[5] * 256);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::GetAverageCurrent()
{
	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x20, 0x27, 0x00,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			AverageCurrent = (short)(bparam[4] + bparam[5] * 256);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
bool 
EPOS::GetPosition()
{
 	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x60, 0x64, 0x00,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			ActualPosition = (int)(bparam[4] + bparam[5] * 256 + bparam[6] * 65536 + bparam[7] * 16777216);		
			return true;
		}
	}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////
//
bool 
EPOS::GetVelocity()
{
 	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x60, 0x6c, 0x00,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			ActualVelocity = (int)(bparam[4] + bparam[5] * 256 + bparam[6] * 65536 + bparam[7] * 16777216);		
			return true;
		}
	}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::GetProfileVelocity()
{
	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x60, 0x81, 0x00,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			ProfileVelocity = (unsigned int)(bparam[4] + bparam[5] * 256 + bparam[6] * 65536 + bparam[7]* 16777216);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetProfileVelocity(unsigned int velocity)
{
 	bool rs;
	unsigned char bparam[10];

	ProfileVelocity = velocity;
	bparam[0] = (unsigned char)(0x000000ff & velocity);
	bparam[1] = (unsigned char)((0x0000ff00 & velocity) >> 8);
	bparam[2] = (unsigned char)((0x00ff0000 & velocity) >> 16);
	bparam[3] = (unsigned char)((0xff000000 & velocity) >> 24);
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0x81, 0x00, bparam);
	if (rs) {
		break;
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetMaxProfileVelocity(unsigned int velocity)
{
 	bool rs;
	unsigned char bparam[10];

	MaxProfileVelocity = velocity;
	bparam[0] = (unsigned char)(0x000000ff & velocity);
	bparam[1] = (unsigned char)((0x0000ff00 & velocity) >> 8);
	bparam[2] = (unsigned char)((0x00ff0000 & velocity) >> 16);
	bparam[3] = (unsigned char)((0xff000000 & velocity) >> 24);
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0x7f, 0x00, bparam);
	if (rs) {
		break;
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
 
void 
EPOS::GetProfileDeceleration()
{
 	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x60, 0x84, 0x00,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			ProfileDeceleration = (unsigned int)(bparam[4]+bparam[5]*256+bparam[6]*65536+bparam[7]*16777216);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetProfileDeceleration(unsigned int deceleration)
{
	bool rs;
	unsigned char bparam[10];

	ProfileDeceleration = deceleration;
	bparam[0] = (unsigned char)(0x000000ff & deceleration);
	bparam[1] = (unsigned char)((0x0000ff00 & deceleration) >> 8);
	bparam[2] = (unsigned char)((0x00ff0000 & deceleration) >> 16);
	bparam[3] = (unsigned char)((0xff000000 & deceleration) >> 24);
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0x84, 0x00, bparam);
	if (rs) {
		break;
	}
	}
}


////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::GetProfileAcceleration()
{
	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x60, 0x83, 0x00,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			ProfileAcceleration = (unsigned int)(bparam[4]+bparam[5]*256+bparam[6]*65536+bparam[7]*16777216);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetProfileAcceleration(unsigned int acceleration)
{
	bool rs;
	unsigned char bparam[10];

	ProfileAcceleration = acceleration;
	bparam[0] = (unsigned char)(0x000000ff & acceleration);
	bparam[1] = (unsigned char)((0x0000ff00 & acceleration) >> 8);
	bparam[2] = (unsigned char)((0x00ff0000 & acceleration) >> 16);
	bparam[3] = (unsigned char)((0xff000000 & acceleration) >> 24);
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0x83, 0x00, bparam);
	if (rs) {
		break;	
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::GetPositionWindow()
{
 	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x60, 0x67, 0x00,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			PositionWindow = (unsigned int)(bparam[4]+bparam[5]*256+bparam[6]*65536+bparam[7]*16777216);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetPositionWindow(unsigned int window)
{
	bool rs;
	unsigned char bparam[10];

	PositionWindow = window;
	bparam[0] = (unsigned char)(0x000000ff & window);
	bparam[1] = (unsigned char)((0x0000ff00 & window) >> 8);
	bparam[2] = (unsigned char)((0x00ff0000 & window) >> 16);
	bparam[3] = (unsigned char)((0xff000000 & window) >> 24);
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0x67, 0x00, bparam);
	if (rs) {
		break;
	}
	}
}


////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::GetPositionWindowTime()
{
	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 
	for (int k=0;k<TRY;k++) {
	if (readObject(0x60, 0x68, 0x00,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			PositionWindowTime = (unsigned short)(bparam[4] + bparam[5] * 256);
			break;
		}
	}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SetPositionWindowTime(unsigned short time)
{
	bool rs;
	unsigned char bparam[10];

	PositionWindowTime = time;
	bparam[0] = (unsigned char)(0x00ff & time);
	bparam[1] = (unsigned char)((0xff00 & time) >> 8);
	bparam[2] = 0x00;
	bparam[3] = 0x00;
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0x68, 0x00, bparam);
	if (rs) {
		break;
	}
	}
}


////////////////////////////////////////////////////////////////////////////////
//
bool 
EPOS::SetOperationMode(char mode)
{
	bool rs;
	unsigned char bparam[10];

	OperationMode = mode;
	bparam[0] = mode;
	bparam[1] = 0x00;
	bparam[2] = 0x00;
	bparam[3] = 0x00;
	//printf("\nSetOperationMode : %x\n",OperationMode);
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0x60, 0x00, bparam);
	if (rs) {
		return true;
	}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////
//
bool 
EPOS::SetMotionProfileType(char profileType)
{
	bool rs;
	unsigned char bparam[10];

	MotionProfileType = profileType;
	bparam[0] = profileType;
	bparam[1] = 0x00;
	bparam[2] = 0x00;
	bparam[3] = 0x00;
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0x86, 0x00, bparam);
	if (rs) {
		return true;
	}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////
//
bool 
EPOS::SetTargetPosition(int position)
{
	bool rs;
	unsigned char bparam[10];

#ifdef DEBUG
	printf("setting position to %i...\n",position);
#endif
	PositionProfileTargetPosition = position;
	bparam[0] = (unsigned char)(0x000000ff & position);
	bparam[1] = (unsigned char)((0x0000ff00 & position) >> 8);
	bparam[2] = (unsigned char)((0x00ff0000 & position) >> 16);
	bparam[3] = (unsigned char)((0xff000000 & position) >> 24);
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0x7a, 0x00, bparam);
	if (rs) {
		return true;
	}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////
//
bool 
EPOS::SetTargetVelocity(int velocity)
{
	bool rs;
	unsigned char bparam[10];

#ifdef DEBUG
	printf("setting velocity to %i...\n",velocity);
#endif
	bparam[0] = (unsigned char)(0x000000ff & velocity);
	bparam[1] = (unsigned char)((0x0000ff00 & velocity) >> 8);
	bparam[2] = (unsigned char)((0x00ff0000 & velocity) >> 16);
	bparam[3] = (unsigned char)((0xff000000 & velocity) >> 24);
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x60, 0xff, 0x00, bparam);
	if (rs) {
		return true;
	}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////
//
bool 
EPOS::Store(void)
{
	bool rs;
	unsigned char bparam[10];

#ifdef DEBUG
	printf("storing parameter...\n");
#endif
	bparam[0] = 0x73; // 's'
	bparam[1] = 0x61; // 'a'
	bparam[2] = 0x76; // 'v'
	bparam[3] = 0x65; // 'e'
	for (int k=0;k<TRY;k++) {
	rs = writeObject(0x10, 0x10, 0x01, bparam);
	if (rs) {
		return true;
	}
	}
	return false;
}



////////////////////////////////////////////////////////////////////////////////
//
bool 
EPOS::MoveToEnableOperation()
{
 	unsigned short statwd = 0x0000;

	if(!GetStatusWord()) return false;
	statwd = StatusWord;
#ifdef DEBUG	
	printf("Unmasked StatusWord: %x\n",statwd);
#endif
	statwd = (unsigned short)(statwd & 0x417f); // maskoff don't care bits
#ifdef DEBUG	
	printf("StatusWord: %x\n",statwd);
#endif

	switch (statwd)
	{
		case 0x0000: // start state
			printf("\t====\tEPOS %s in start state\t====\n", port);
			return false;
		case 0x0100: // Not Ready to Switch On
			printf("\t====\tEPOS %s not ready to switch on\t====\n", port);
			return false;
		case 0x0140: // Switch On Disabled
			printf("\t====\tEPOS %s switch on disabled\t====\n", port);
			ShutDown();
			usleep(100000);
			SwitchOn();
			//SwitchOnEnable();
			usleep(100000);
			EnableOperation();
			usleep(100000);
			return false;  // false
		case 0x0121: // Ready to Switch On
			printf("\t====\tEPOS %s ready to switch on\t====\n", port);
			SwitchOn();
			//SwitchOnEnable();
			usleep(50000);
			EnableOperation();
			return false;  // false
		case 0x0123: // Switched On
			printf("\t====\tEPOS %s switched on\t====\n", port);
			EnableOperation();
			return false;  // false
		case 0x4123: // Refresh
			printf("\t====\tEPOS %s refresh\t====\n", port);
			return false;
		case 0x4133: // Measure Init
			printf("\t====\tEPOS %s measure init\t====\n", port);
			return false;
		case 0x0137: // Operation Enable
			printf("\t====\tEPOS %s operation enabled\t====\n", port);
			return true;
		case 0x0117: // Quick Stop Active
			printf("\t====\tEPOS %s quick stop active\t====\n", port);
			EnableOperation();
			return false;  // false
		case 0x010f: // Fault Reaction Active (disabled)
			printf("\t====\tEPOS %s fault. Drive disabled\t====\n", port);
			return false;
		case 0x011f: // Fault Reaction Active (enabled)
			printf("\t====\tEPOS %s fault. Drive enabled\t====\n", port);
			return false;
		case 0x0108: // Fault
			printf("\t====\tEPOS %s fault. Resetting now...\t====\n", port);
			FaultReset();
			usleep(100000);
			ShutDown();
			usleep(100000);
			SwitchOn();
			usleep(100000);
			EnableOperation();
			return false;  // false
		default:
			printf("\t====\tEPOS %s unknown status %x\t====\n", port, statwd);
			FaultReset();
			usleep(100000);
			ShutDown();
			usleep(100000);
			SwitchOn();
			usleep(100000);
			EnableOperation();
			return false;  // false
	} //switch (statwd)
} //MoveToEnableOperation()

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::ShutDown()
{
 	unsigned short cwd = 0x0000;
	if (!GetControlWord()) printf("Shutdown failed\n");
	cwd = ControlWord;
	cwd = (unsigned short)(cwd & 0xff7e);
	cwd = (unsigned short)(cwd | 0x0006);
	if (!SetControlWord(cwd)) printf("Shutdown failed\n");
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SwitchOn()
{
 	unsigned short cwd = 0x0000;
	if (!GetControlWord()) printf("SwitchOn failed\n");
	cwd = ControlWord;
	cwd = (unsigned short)(cwd & 0xff7f);
	cwd = (unsigned short)(cwd | 0x0007);
	if (!SetControlWord(cwd)) printf("SwitchOn failed\n");
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::SwitchOnEnable()
{
 	unsigned short cwd = 0x0000;
	if (!GetControlWord()) printf("SwitchOnEnable failed\n");
	cwd = ControlWord;
	cwd = (unsigned short)(cwd & 0xff7f);
	cwd = (unsigned short)(cwd | 0x000f);
	if (!SetControlWord(cwd)) printf("SwitchOnEnable failed A\n");
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::DisableOperation()
{
 	unsigned short cwd = 0x0000;
	if (!GetControlWord()) printf("DisableOperation failed\n");
	cwd = ControlWord;
	cwd = (unsigned short)(cwd & 0xff77);
	cwd = (unsigned short)(cwd | 0x0007);
	if (!SetControlWord(cwd)) printf("DisableOperation failed A\n");
}

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::EnableOperation()
{
 	unsigned short cwd = 0x0000;
	if (!GetControlWord()) printf("EnableOperation failed\n");
	cwd = ControlWord;
	cwd = (unsigned short)(cwd & 0xff7f);
	cwd = (unsigned short)(cwd | 0x000f);
	if (!SetControlWord(cwd)) printf("EnableOperation failed A\n");
}

////////////////////////////////////////////////////////////////////////////////
//
bool 
EPOS::FaultReset()
{
 	unsigned short cwd = 0x0000;
	bool ret;
	ret = true;
	if (!GetControlWord()) {
		ret = false;
		printf("FaultReset failed\n");
	}
	cwd = ControlWord;
	cwd = (unsigned short)(cwd & 0xff7f);
	if (!SetControlWord(cwd)) {
		ret = false;
		printf("FaultReset failed A\n");
	}
	cwd = ControlWord;
	cwd = (unsigned short)(cwd | 0x0080);
	if (!SetControlWord(cwd)) {
		ret = false;
		printf("FaultReset failed B\n");
	}
	return ret;
}

////////////////////////////////////////////////////////////////////////////////
// NMT Service 
bool 
EPOS::sendNMTService(unsigned char nidxhigh, unsigned char nidxlow, unsigned char cmdhigh,unsigned char cmdlow)
{
	unsigned char sbuff[10];
	unsigned short x, crc, err, err1;
	int len,res;

	// send opcode 
	sbuff[0] = 0x0e; // opcode for NMT Service
	res=write(fd,sbuff,1);

	// wait for acknowledge from EPOS
	if (!checkAck())
	{
	#ifdef DEBUG
		printf("writeObject: Did not get acknowledge after opcode sent\n");
	#endif
		return false;
	}
	
	// send len-1
	sbuff[0] = 0x01; // len-1 
	res=write(fd,sbuff,1);

	// send data
	sbuff[0] = nidxlow; // node id low byte
	sbuff[1] = nidxhigh; // node id high byte
	sbuff[2] = cmdlow; // command low byte
	sbuff[3] = cmdhigh; // command high byte
	res=write(fd,sbuff,4);

	// calc crc and send
	data[0] = 0x0e01;
	x = (unsigned short)(nidxhigh * 256);
	data[1] = (unsigned short)(x + nidxlow);
	x = (unsigned short)(cmdhigh * 256);
	data[2] = (unsigned short)(x + cmdlow);
	data[3] = 0x0000; // zero data
	x = CRCCalc(data, 4);
	crc = x;
	sbuff[0] = (unsigned char)(x & 0x00ff);
	sbuff[1] = (unsigned char)((x & 0xff00) >> 8);
	res=write(fd,sbuff,2);

	// wait for end acknowledge from EPOS
	if (!checkAck())
	{
	#ifdef DEBUG
		printf("sendNMTService: Did not get acknowledge after data sent\n");
	#endif
		return false;
	}
	return true;
} // bool EPOS::sendNMTService

////////////////////////////////////////////////////////////////////////////////
//
void 
EPOS::GetNodeID()
{
	unsigned char bparam[10];
	int lx=0;
	unsigned int err; 

	if (readObject(0x20, 0x00, 0x00,bparam,lx))
	{
		// check for error code
		err = getError(bparam);
		if (err == 0)
		{
			NodeID = (unsigned char)(bparam[4]);
		}
	}
}


